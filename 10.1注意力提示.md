```python
import torch
from d2l import torch as d2l
```


```python
def show_heatmaps(matrices,xlabel,ylabel,titles=None,figsize=(2.5,2.5),cmap='Reds'):
    """显示矩阵热图"""
    d2l.use_svg_display()
    #调用d2l的use_svg_display函数，设置绘图的显示格式为SVG（矢量图）。
# 优势：SVG 是矢量图形，放大后不会模糊，比位图（PNG/JPG）更适合学术绘图和可视化。
    num_rows,num_cols = matrices.shape[0],matrices.shape[1]
    fig,axes = d2l.plt.subplots(num_rows,num_cols,figsize=figsize,sharex=True,sharey=True,squeeze=False)
#调用d2l.plt.subplots创建画布和子图（d2l.plt是matplotlib.pyplot的封装）
    #sharex=True/sharey=True：所有子图共享 X 轴和 Y 轴的刻度，避免重复标注，简化可视化。
    #squeeze=False：强制返回的axes为二维数组（即使只有 1 行 1 列），避免后续循环时的维度问题。
    #fig：整个画布对象。
# axes：子图轴对象的二维数组，形状为(num_rows, num_cols)。
    for i,(row_axes,row_matrices) in enumerate(zip(axes,matrices)):
        #这里的 **“行矩阵”就是指matrices在第一个维度（num_rows）上取一个索引对应的元素，其形状为(num_cols, h, w)，代表热图画布中某一行的所有热图矩阵 **。
# 2. 结合代码案例理解 “行矩阵”
# 在你的代码中，attention_weights的形状是(1, 1, 10, 10)，对应：
# num_rows=1：热图画布只有1 行；
# num_cols=1：这一行只有1 列（1 个热图）；
# h=10, w=10：单个热图是 10×10 的矩阵。
        #1. 先明确axes和matrices的实际迭代行为
# 首先要区分对象的维度和对象的可迭代维度：
# axes：是matplotlib返回的二维轴对象数组（形状为(num_rows, num_cols)），当对其进行迭代时，Python 会默认按行遍历（即取第一个维度的元素），每次迭代得到的是一行的轴对象列表（形状为(num_cols,)）。
# matrices：是四维张量（形状为(num_rows, num_cols, h, w)），当对其进行迭代时，PyTorch 的张量会默认按最外层维度遍历（即第一个维度num_rows），每次迭代得到的是一个三维张量（形状为(num_cols, h, w)），也就是我们之前说的 “行矩阵”。
# 简单来说：两者的最外层迭代长度都是num_rows，这是zip能配对的核心前提
        for j,(ax,matrix) in enumerate(zip(row_axes,row_matrices)):
            #两层嵌套循环的本质是：
# 外层循环：按行遍历热图网格，把 “一行的轴对象” 和 “一行的矩阵张量” 配对；
# 内层循环：按列遍历热图网格，把 “单个轴对象” 和 “单个热图矩阵” 最终配对，为绘制热图做准备。
            pcm = ax.imshow(matrix.detach().numpy(),cmap=cmap)
            #matrix.detach()：从 PyTorch 的计算图中分离张量，避免后续操作影响计算图（可视化无需求导）。
# .numpy()：将 PyTorch 张量转换为 NumPy 数组（matplotlib仅支持 NumPy 数组绘图）。
# ax.imshow()：绘制二维数组的热图，返回pcm（伪彩色图对象），用于后续添加颜色条。
# cmap=cmap：应用指定的颜色映射方案。
            if i == num_rows -1:
                ax.set_xlabel(xlabel)
            if j == 0:
                ax.set_ylabel(ylabel)
            if titles:
                ax.set_title(titles[j])
    fig.colorbar(pcm,ax=axes,shrink=0.6);
```


```python
attention_weights = torch.eye(10).reshape((1,1,10,10))
show_heatmaps(attention_weights,xlabel='Keys',ylabel='Queries')
```


    
![svg](output_2_0.svg)
    



```python

```
